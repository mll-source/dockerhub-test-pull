name: Docker

on:
  workflow_dispatch: {}
  push:
    branches:
      - master

env:
  ALIYUN_REGISTRY: ${{ secrets.ALIYUN_REGISTRY }}
  ALIYUN_NAME_SPACE: ${{ secrets.ALIYUN_NAME_SPACE }}
  ALIYUN_REGISTRY_USER: ${{ secrets.ALIYUN_REGISTRY_USER }}
  ALIYUN_REGISTRY_PASSWORD: ${{ secrets.ALIYUN_REGISTRY_PASSWORD }}

jobs:
  build:
    name: Pull and Push to Aliyun
    runs-on: ubuntu-latest
    steps:
      - name: Docker Setup Buildx
        uses: docker/setup-buildx-action@v3

      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Build and push image Aliyun
        run: |
          echo "$ALIYUN_REGISTRY_PASSWORD" | docker login -u "$ALIYUN_REGISTRY_USER" --password-stdin "$ALIYUN_REGISTRY"
          
          # 数据预处理,判断镜像是否重名
          declare -A duplicate_images
          declare -A temp_map
          while IFS= read -r line; do
            # 忽略空行与注释
            [[ -z "$line" ]] && continue
            if echo "$line" | grep -q '^\s*#'; then
              continue
            fi
            
            # 获取镜像的完整名称，例如kasmweb/nginx:1.25.3（命名空间/镜像名:版本号）
            image=$(echo "$line" | awk '{print $NF}')
            # 将@sha256:等字符删除
            image="${image%%@*}"
            echo "image $image"
            # 获取镜像名:版本号 例如nginx:1.25.3
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            echo "image_name_tag $image_name_tag"
            # 获取命名空间 例如kasmweb, 这里有种特殊情况 docker.io/nginx，把docker.io当成命名空间，也OK
            name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
            echo "name_space: $name_space"
            # 这里不要是空值影响判断
            name_space="${name_space}_"
            # 获取镜像名例如nginx
            image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
            echo "image_name: $image_name"
            
            # 如果镜像存在于数组中，则添加temp_map
            if [[ -n "${temp_map[$image_name]}" ]]; then
               # 如果temp_map已经存在镜像名，判断是不是同一命名空间
               if [[ "${temp_map[$image_name]}" != "$name_space" ]]; then
                 echo "duplicate image name: $image_name"
                 duplicate_images[$image_name]="true"
               fi
            else
               # 存镜像的命名空间
               temp_map[$image_name]=$name_space
            fi       
          done < images.txt
          
          while IFS= read -r line; do
            # 忽略空行与注释
            [[ -z "$line" ]] && continue
            if echo "$line" | grep -q '^\s*#'; then
              continue
            fi

            # 使用 set -- 来解析命令行参数
            set -- $line  # 注意：这里故意不加引号，让 shell 拆分单词

            platform=""
            image=""

            # 解析参数
            while [[ $# -gt 0 ]]; do
              case "$1" in
                --platform=*)
                  platform="${1#--platform=}"
                  shift
                  ;;
                --platform)
                  # 支持 --platform linux/amd64 形式（虽然 docker 不这么用，但健壮点）
                  if [[ -n "$2" && "$2" != --* ]]; then
                    platform="$2"
                    shift 2
                  else
                    echo "Error: --platform requires a value"
                    exit 1
                  fi
                  ;;
                *)
                  # 第一个非选项参数就是镜像名
                  if [[ -z "$image" ]]; then
                    image="$1"
                  else
                    echo "Warning: extra argument ignored: $1"
                  fi
                  shift
                  ;;
              esac
            done

            if [[ -z "$image" ]]; then
              echo "Error: no image specified in line: $line"
              continue
            fi

            echo "Pulling image: $image with platform: ${platform:-default}"

            # 执行 pull（如果指定了 platform）
            if [[ -n "$platform" ]]; then
              docker pull --platform "$platform" "$image"
            else
              docker pull "$image"
            fi

            # 后续处理：生成 new_image 名称等（和你原来逻辑一致）
            # 注意：这里 image 是纯镜像名，如 nginx:latest

            # 获取 镜像名:tag
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            image_name_tag="${image_name_tag%%@*}"  # 去掉 @sha256...

            # 获取命名空间（用于去重）
            name_space=$(echo "$image" | awk -F'/' '
              {
                if (NF == 3) print $2;
                else if (NF == 2) print $1;
                else print ""
              }
            ')
            image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')

            # 构建前缀（和你原来逻辑一致）
            platform_prefix=""
            if [[ -n "$platform" ]]; then
              platform_prefix="${platform//\//_}_"
            fi

            name_space_prefix=""
            if [[ -n "${duplicate_images[$image_name]}" ]] && [[ -n "$name_space" ]]; then
              name_space_prefix="${name_space}_"
            fi

            new_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/${platform_prefix}${name_space_prefix}${image_name_tag}"
            echo "Tagging $image -> $new_image"
            docker tag "$image" "$new_image"
            echo "Pushing $new_image"
            docker push "$new_image"

          done < images.txt
